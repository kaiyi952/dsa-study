##  物理结构：连续与分散

#### 所有数据结构都是由数组、链表或两者的组合实现的
**连续**：数组  
**分散**：链表  
**基于数组可实现**：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。  
**基于链表可实现**：栈、队列、哈希表、树、堆、图等。  

#### 时间复杂度：

|     | 查找   | 插入   | 删除   |     |
| --- | ---- | ---- | ---- | --- |
| 数组  | O(1) | O(n) | O(n) |     |
| 链表  | O(n) | O(1) | O(1) |     |
| 哈希表 |      |      |      |     |
| 树   |      |      |      |     |
| 堆   |      |      |      |     |
| 图   |      |      |      |     |

### 链表：
**组成单位**：节点  
node（节点）= value（值）+ 引用（指针）  
数组整体是一个变量，比如数组 `nums` 包含元素 `nums[0]` 和 `nums[1]` 等，而链表是由多个独立的节点对象组成的。    
**初始化链表：**  
```python
class ListNode:
    """链表节点类"""
    def __init__(self, val: int):
        self.val: int = val               # 节点值
        self.next: ListNode | None = None # 指向下一节点的引用
        
# 初始化链表 1 -> 3 -> 2 -> 5 -> 4
# 初始化各个节点
n0 = ListNode(1)
n1 = ListNode(3)
n2 = ListNode(2)
n3 = ListNode(5)
n4 = ListNode(4)
# 构建节点之间的引用
n0.next = n1
n1.next = n2
n2.next = n3
n3.next = n4
```
**用数组模拟链表**：  

```python
class ArrayLinkedList:
    def __init__(self):
        self.values = []  # 存储值
        self.nexts = []   # 存储 next 指针
        self.head_index = None  # 头部索引

    def add(self, value):
        new_index = len(self.values)  # 新节点索引
        self.values.append(value)
        self.nexts.append(self.head_index)  # 旧 head 变成新节点的 next
        self.head_index = new_index  # 头部指向新节点

    def traverse(self):
        index = self.head_index
        while index is not None:
            print(self.values[index], end=" -> ")
            index = self.nexts[index]
        print("None")

# 使用示例
list = ArrayLinkedList()
list.add(1)
list.add(2)
list.add(3)
list.traverse()  # 输出 3 -> 2 -> 1 -> None

```

#### 常见的链表类型：  
**单向链表**：单向链表的节点包含值和指向下一节点的引用两项数据。单向链表通常用于实现栈、队列、哈希表和图等数据结构。  
**环形链表**：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。双向链表常用于需要快速查找前一个和后一个元素的场景。  
**双向链表**：双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。  
**双向链表示例**：  
```python
class ListNode:
    """双向链表节点类"""
    def __init__(self, val: int):
        self.val: int = val                # 节点值
        self.next: ListNode | None = None  # 指向后继节点的引用
        self.prev: ListNode | None = None  # 指向前驱节点的引用
```


### 栈与队列
**栈stack**是一种遵循先入后出逻辑的线性数据结构。  
#### 基于链表实现栈：
```python
class LinkedListStack:
    """基于链表实现的栈"""

    def __init__(self):
        """构造方法"""
        self._peek: ListNode | None = None
        self._size: int = 0

    def size(self) -> int:
        """获取栈的长度"""
        return self._size

    def is_empty(self) -> bool:
        """判断栈是否为空"""
        return self._size == 0

    def push(self, val: int):
        """入栈"""
        node = ListNode(val)
        node.next = self._peek
        self._peek = node
        self._size += 1

    def pop(self) -> int:
        """出栈"""
        num = self.peek()
        self._peek = self._peek.next
        self._size -= 1
        return num

    def peek(self) -> int:
        """访问栈顶元素"""
        if self.is_empty():
            raise IndexError("栈为空")
        return self._peek.val

    def to_list(self) -> list[int]:
        """转化为列表用于打印"""
        arr = []
        node = self._peek
        while node:
            arr.append(node.val)
            node = node.next
        arr.reverse()
        return arr
```
#### 基于数组实现栈：
```python
class ArrayStack:
    """基于数组实现的栈"""

    def __init__(self):
        """构造方法"""
        self._stack: list[int] = []

    def size(self) -> int:
        """获取栈的长度"""
        return len(self._stack)

    def is_empty(self) -> bool:
        """判断栈是否为空"""
        return self.size() == 0

    def push(self, item: int):
        """入栈"""
        self._stack.append(item)

    def pop(self) -> int:
        """出栈"""
        if self.is_empty():
            raise IndexError("栈为空")
        return self._stack.pop()

    def peek(self) -> int:
        """访问栈顶元素"""
        if self.is_empty():
            raise IndexError("栈为空")
        return self._stack[-1]

    def to_list(self) -> list[int]:
        """返回列表用于打印"""
        return self._stack
```

##### 时间效率：
**在基于数组的实现中**，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为 O(n) 。  
**在基于链表的实现中**，链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。  

#### 栈的典型应用：
**浏览器中的后退与前进、软件中的撤销与反撤销**。  
**程序内存管理**。 

**队列queue**是一种遵循先入先出规则的线性数据结构。  
#### 用链表实现队列：
```python
class LinkedListQueue:
    """基于链表实现的队列"""

    def __init__(self):
        """构造方法"""
        self._front: ListNode | None = None  # 头节点 front
        self._rear: ListNode | None = None  # 尾节点 rear
        self._size: int = 0

    def size(self) -> int:
        """获取队列的长度"""
        return self._size

    def is_empty(self) -> bool:
        """判断队列是否为空"""
        return self._size == 0

    def push(self, num: int):
        """入队"""
        # 在尾节点后添加 num
        node = ListNode(num)
        # 如果队列为空，则令头、尾节点都指向该节点
        if self._front is None:
            self._front = node
            self._rear = node
        # 如果队列不为空，则将该节点添加到尾节点后
        else:
            self._rear.next = node
            self._rear = node
        self._size += 1

    def pop(self) -> int:
        """出队"""
        num = self.peek()
        # 删除头节点
        self._front = self._front.next
        self._size -= 1
        return num

    def peek(self) -> int:
        """访问队首元素"""
        if self.is_empty():
            raise IndexError("队列为空")
        return self._front.val

    def to_list(self) -> list[int]:
        """转化为列表用于打印"""
        queue = []
        temp = self._front
        while temp:
            queue.append(temp.val)
            temp = temp.next
        return queue
```


#### 双向队列：
在队列中，我们仅能删除头部元素或在尾部添加元素。如图 5-7 所示，双向队列（double-ended queue）提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作。  

### 哈希表
